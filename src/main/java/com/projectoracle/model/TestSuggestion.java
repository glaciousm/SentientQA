package com.projectoracle.model;

import com.projectoracle.service.MethodInfo;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Represents a test case suggestion generated by the system.
 * Contains information about what to test, how to test it, and the expected outcome.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TestSuggestion {

    private UUID id;
    private MethodInfo methodInfo;
    private String testName;
    private String inputValues;
    private String expectedOutput;
    private String category;
    private LocalDateTime createdAt;
    private boolean implemented;
    private UUID implementedTestId;

    /**
     * Generate a test method name based on the suggestion
     * @return a method name in the format testMethodName_scenario
     */
    public String generateTestMethodName() {
        String baseMethodName = methodInfo.getMethodName();

        // Ensure first character is uppercase for the test method name
        baseMethodName = Character.toUpperCase(baseMethodName.charAt(0)) + baseMethodName.substring(1);

        // Create a scenario part from the test name
        String scenarioPart = testName
                .replaceAll("[^a-zA-Z0-9]", " ")  // Replace non-alphanumeric with spaces
                .trim()
                .replaceAll("\\s+", "_");         // Replace spaces with underscores

        // If scenario is too long, truncate it
        if (scenarioPart.length() > 30) {
            scenarioPart = scenarioPart.substring(0, 30);
        }

        return "test" + baseMethodName + "_" + scenarioPart;
    }

    /**
     * Generate code for a test case based on this suggestion
     * @return Java code for a JUnit 5 test
     */
    public String generateTestCode() {
        StringBuilder codeBuilder = new StringBuilder();

        // Package and imports
        codeBuilder.append("package ").append(methodInfo.getPackageName()).append(".test;\n\n");
        codeBuilder.append("import org.junit.jupiter.api.Test;\n");
        codeBuilder.append("import static org.junit.jupiter.api.Assertions.*;\n");
        codeBuilder.append("import ").append(methodInfo.getPackageName()).append(".")
                   .append(methodInfo.getClassName()).append(";\n\n");

        // Test class
        codeBuilder.append("public class Test").append(methodInfo.getClassName()).append(" {\n\n");

        // Test method
        codeBuilder.append("    /**\n");
        codeBuilder.append("     * ").append(testName).append("\n");
        codeBuilder.append("     * Category: ").append(category).append("\n");
        codeBuilder.append("     */\n");
        codeBuilder.append("    @Test\n");
        codeBuilder.append("    public void ").append(generateTestMethodName()).append("() {\n");

        // Method implementation
        codeBuilder.append("        // Arrange\n");
        codeBuilder.append("        ").append(methodInfo.getClassName()).append(" instance = new ")
                   .append(methodInfo.getClassName()).append("();\n");

        // Add input setup based on the suggestion
        codeBuilder.append("        // Input values: ").append(inputValues).append("\n");

        // Add test logic
        codeBuilder.append("\n        // Act\n");

        // Handle return type
        if (!"void".equals(methodInfo.getReturnType())) {
            codeBuilder.append("        ").append(methodInfo.getReturnType()).append(" result = ");
        } else {
            codeBuilder.append("        ");
        }

        // Method call
        codeBuilder.append("instance.").append(methodInfo.getMethodName())
                   .append("(").append(generateMethodParameters()).append(");\n");

        // Assert section
        codeBuilder.append("\n        // Assert\n");
        codeBuilder.append("        // Expected: ").append(expectedOutput).append("\n");

        if (!"void".equals(methodInfo.getReturnType())) {
            codeBuilder.append("        ").append(generateAssertion(methodInfo.getReturnType())).append("\n");
        } else {
            codeBuilder.append("        ").append(generateVerification()).append("\n");
        }

        // Close method and class
        codeBuilder.append("    }\n");
        codeBuilder.append("}\n");

        return codeBuilder.toString();
    }
    
    /**
     * Generates parameter values for a method call based on parameter types.
     * @return String representation of method parameters
     */
    private String generateMethodParameters() {
        if (methodInfo.getParameters() == null || methodInfo.getParameters().isEmpty()) {
            return "";
        }
        
        // Create default parameter values based on what we know
        // Since ParameterInfo is not directly accessible, handle based on parameter count
        List<String> parameters = new ArrayList<>();
        int paramCount = methodInfo.getParameters() != null ? methodInfo.getParameters().size() : 0;
        
        for (int i = 0; i < paramCount; i++) {
            // Fallback to generic default values
            parameters.add("/* param" + (i+1) + " */");
        }
                
        return String.join(", ", parameters);
    }
    
    /**
     * Generates a default value for a given type.
     * @param type The Java type as a string
     * @return A string representation of a default value for the type
     */
    private String generateDefaultValueForType(String type) {
        switch (type) {
            case "int":
            case "Integer":
                return "42";
            case "long":
            case "Long":
                return "42L";
            case "double":
            case "Double":
                return "42.0";
            case "float":
            case "Float":
                return "42.0f";
            case "boolean":
            case "Boolean":
                return "true";
            case "char":
            case "Character":
                return "'a'";
            case "byte":
            case "Byte":
                return "(byte) 1";
            case "short":
            case "Short":
                return "(short) 42";
            case "String":
                return "\"test\"";
            default:
                if (type.contains("List") || type.contains("ArrayList") || type.contains("LinkedList")) {
                    return "new java.util.ArrayList<>()";
                } else if (type.contains("Set") || type.contains("HashSet")) {
                    return "new java.util.HashSet<>()";
                } else if (type.contains("Map") || type.contains("HashMap")) {
                    return "new java.util.HashMap<>()";
                } else {
                    return "null /* Create a proper instance of " + type + " */";
                }
        }
    }
    
    /**
     * Generates an appropriate assertion based on the return type.
     * @param returnType The return type of the method
     * @return A string containing the appropriate assertion
     */
    private String generateAssertion(String returnType) {
        switch (returnType) {
            case "boolean":
            case "Boolean":
                return "assertTrue(result, \"Expected method to return true\");";
            case "int":
            case "Integer":
            case "long":
            case "Long":
            case "double":
            case "Double":
            case "float":
            case "Float":
            case "short":
            case "Short":
            case "byte":
            case "Byte":
            case "char":
            case "Character":
                return "assertEquals(" + generateExpectedValueForType(returnType) + ", result, \"Method returned unexpected value\");";
            case "String":
                return "assertEquals(\"expected string\", result, \"Method returned unexpected string\");";
            case "void":
                return "// No return value to assert";
            default:
                if (returnType.contains("List") || returnType.contains("Set") || returnType.contains("Collection")) {
                    return "assertFalse(result.isEmpty(), \"Expected non-empty collection\");";
                } else if (returnType.contains("Map")) {
                    return "assertFalse(result.isEmpty(), \"Expected non-empty map\");";
                } else {
                    return "assertNotNull(result, \"Expected non-null result\");";
                }
        }
    }
    
    /**
     * Generates verification code for void methods.
     * @return A string containing appropriate verification code
     */
    private String generateVerification() {
        return "// Verify method side effects or use mockito to verify interactions\n" +
               "        // For example: verify(mockDependency).someMethod(any());";
    }
    
    /**
     * Generates an expected value for assertions based on the return type.
     * @param type The Java type as a string
     * @return A string representation of an expected value for the type
     */
    private String generateExpectedValueForType(String type) {
        return switch (type) {
            case "int", "Integer" -> "42";
            case "long", "Long" -> "42L";
            case "double", "Double" -> "42.0";
            case "float", "Float" -> "42.0f";
            case "boolean", "Boolean" -> "true";
            case "char", "Character" -> "'a'";
            case "byte", "Byte" -> "(byte) 1";
            case "short", "Short" -> "(short) 42";
            default -> "expected";
        };
    }
}